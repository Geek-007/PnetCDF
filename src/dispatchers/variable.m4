dnl Process this m4 file to produce 'C' language file.
dnl
dnl If you see this line, you can ignore the next one.
/* Do not edit this file. It is produced from the corresponding .m4 source */
dnl
/*
 *  Copyright (C) 2017, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 */
/* $Id$ */

#if HAVE_CONFIG_H
# include <ncconfig.h>
#endif

#include <stdlib.h>

#include <dispatch.h>
#include <pnetcdf.h>
#include <nctypes.h>

/*----< ncmpi_def_var() >----------------------------------------------------*/
/* this API is collective, and must be called in define mode */
int
ncmpi_def_var(int         ncid,    /* IN:  file ID */
              const char *name,    /* IN:  name of variable */
              nc_type     type,
              int         ndims,
              const int  *dimids,
              int        *varidp)
{
    int err;
    PNC *pncp;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_def_var() */
    err = pncp->dispatch->def_var(pncp->ncp, name, type, ndims, dimids, varidp);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_def_var_fill() >-----------------------------------------------*/
/* this API is collective, and must be called in define mode */
int
ncmpi_def_var_fill(int         ncid,    /* IN:  file ID */
                   int         varid,
                   int         nofill,
                   const void *fill_value)
{
    int err;
    PNC *pncp;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_def_var_fill() */
    err = pncp->dispatch->def_var_fill(pncp->ncp, varid, nofill, fill_value);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_inq_varid() >--------------------------------------------------*/
/* This is an independent subroutine */
int
ncmpi_inq_varid(int         ncid,    /* IN:  file ID */
                const char *name,    /* IN:  name of variable */
                int        *varidp)  /* OUT: variable ID */
{
    int err;
    PNC *pncp;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_inq_varid() */
    err = pncp->dispatch->inq_varid(pncp->ncp, name, varidp);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_inq_var() >----------------------------------------------------*/
/* This is an independent subroutine */
int
ncmpi_inq_var(int      ncid,    /* IN:  file ID */
              int      varid,   /* IN:  variable ID */
              char    *name,    /* OUT: name of variable */
              nc_type *xtypep,
              int     *ndimsp,
              int     *dimids,
              int     *nattsp)
{
    int err;
    PNC *pncp;

    /* using NC_GLOBAL in varid is illegal for this API. See
     * http://www.unidata.ucar.edu/mailing_lists/archives/netcdfgroup/2015/msg00196.html
     */
    if (varid == NC_GLOBAL) return NC_EGLOBAL;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_inq_var() */
    err = pncp->dispatch->inq_var(pncp->ncp, varid, name, xtypep, ndimsp,
                                  dimids, nattsp, NULL, NULL, NULL);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_inq_varname() >------------------------------------------------*/
/* This is an independent subroutine */
int
ncmpi_inq_varname(int   ncid,    /* IN:  file ID */
                  int   varid,   /* IN:  variable ID */
                  char *name)    /* OUT: name of variable */
{
    int err;
    PNC *pncp;

    /* using NC_GLOBAL in varid is illegal for this API. See
     * http://www.unidata.ucar.edu/mailing_lists/archives/netcdfgroup/2015/msg00196.html
     */
    if (varid == NC_GLOBAL) return NC_EGLOBAL;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_inq_varname() */
    err = pncp->dispatch->inq_var(pncp->ncp, varid, name, NULL, NULL,
                                  NULL, NULL, NULL, NULL, NULL);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_inq_vartype() >------------------------------------------------*/
/* This is an independent subroutine */
int
ncmpi_inq_vartype(int      ncid,    /* IN:  file ID */
                  int      varid,   /* IN:  variable ID */
                  nc_type *xtypep)  /* OUT: external type of variable */
{
    int err;
    PNC *pncp;

    /* using NC_GLOBAL in varid is illegal for this API. See
     * http://www.unidata.ucar.edu/mailing_lists/archives/netcdfgroup/2015/msg00196.html
     */
    if (varid == NC_GLOBAL) return NC_EGLOBAL;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_inq_vartype() */
    err = pncp->dispatch->inq_var(pncp->ncp, varid, NULL, xtypep, NULL,
                                  NULL, NULL, NULL, NULL, NULL);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_inq_varndims() >-----------------------------------------------*/
/* This is an independent subroutine */
int
ncmpi_inq_varndims(int  ncid,    /* IN:  file ID */
                   int  varid,   /* IN:  variable ID */
                   int *ndimsp)  /* OUT: number of dimensions of variable */
{
    int err;
    PNC *pncp;

    /* using NC_GLOBAL in varid is illegal for this API. See
     * http://www.unidata.ucar.edu/mailing_lists/archives/netcdfgroup/2015/msg00196.html
     */
    if (varid == NC_GLOBAL) return NC_EGLOBAL;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_inq_varndims() */
    err = pncp->dispatch->inq_var(pncp->ncp, varid, NULL, NULL, ndimsp,
                                  NULL, NULL, NULL, NULL, NULL);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_inq_vardimid() >-----------------------------------------------*/
/* This is an independent subroutine */
int
ncmpi_inq_vardimid(int  ncid,    /* IN:  file ID */
                   int  varid,   /* IN:  variable ID */
                   int *dimids)  /* OUT: dimension IDs of variable */
{
    int err;
    PNC *pncp;

    /* using NC_GLOBAL in varid is illegal for this API. See
     * http://www.unidata.ucar.edu/mailing_lists/archives/netcdfgroup/2015/msg00196.html
     */
    if (varid == NC_GLOBAL) return NC_EGLOBAL;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_inq_vardimid() */
    err = pncp->dispatch->inq_var(pncp->ncp, varid, NULL, NULL, NULL,
                                  dimids, NULL, NULL, NULL, NULL);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_inq_varnatts() >-----------------------------------------------*/
/* This is an independent subroutine */
int
ncmpi_inq_varnatts(int  ncid,    /* IN:  file ID */
                   int  varid,   /* IN:  variable ID */
                   int *nattsp)  /* OUT: number of attributes of variable */
{
    int err;
    PNC *pncp;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_inq_varnatts() */
    err = pncp->dispatch->inq_var(pncp->ncp, varid, NULL, NULL, NULL,
                                  NULL, nattsp, NULL, NULL, NULL);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_inq_varoffset() >----------------------------------------------*/
/* This is an independent subroutine */
int
ncmpi_inq_varoffset(int         ncid,   /* IN: file ID */
                    int         varid,  /* IN: variable ID */
                    MPI_Offset *offset) /* OUT: starting file offset */
{
    int err;
    PNC *pncp;

    /* using NC_GLOBAL in varid is illegal for this API. See
     * http://www.unidata.ucar.edu/mailing_lists/archives/netcdfgroup/2015/msg00196.html
     */
    if (varid == NC_GLOBAL) return NC_EGLOBAL;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_inq_varoffset() */
    err = pncp->dispatch->inq_var(pncp->ncp, varid, NULL, NULL, NULL,
                                  NULL, NULL, offset, NULL, NULL);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_inq_var_fill() >-----------------------------------------------*/
/* this API can be called independently and in both data and define mode */
int
ncmpi_inq_var_fill(int   ncid,
                   int   varid,
                   int  *no_fill,    /* OUT: 1 not fill mode, 0 fill mode */
                   void *fill_value) /* OUT: user-defined or default fill value */
{
    int err;
    PNC *pncp;

    /* using NC_GLOBAL in varid is illegal for this API. See
     * http://www.unidata.ucar.edu/mailing_lists/archives/netcdfgroup/2015/msg00196.html
     */
    if (varid == NC_GLOBAL) return NC_EGLOBAL;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_inq_var_fill() */
    err = pncp->dispatch->inq_var(pncp->ncp, varid, NULL, NULL, NULL,
                                  NULL, NULL, NULL, no_fill, fill_value);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_fill_var_rec() >-----------------------------------------------*/
/* this API is collective and can only be called in collective data mode */
int
ncmpi_fill_var_rec(int        ncid,
                   int        varid,
                   MPI_Offset recno)
{
    int err;
    PNC *pncp;

    /* using NC_GLOBAL in varid is illegal for this API */
    if (varid == NC_GLOBAL) return NC_EGLOBAL;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_fill_var_rec() */
    err = pncp->dispatch->fill_rec(pncp->ncp, varid, recno);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_rename_var() >-------------------------------------------------*/
/* This is an independent subroutine */
int
ncmpi_rename_var(int         ncid,    /* IN: file ID */
                 int         varid,   /* IN: variable ID */
                 const char *newname) /* IN: name of variable */
{
    int err;
    PNC *pncp;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_rename_var() */
    err = pncp->dispatch->rename_var(pncp->ncp, varid, newname);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

include(`foreach.m4')dnl
include(`utils.m4')dnl
dnl
define(`APINAME',`ifelse(`$3',`',`ncmpi_$1_var$2$4',`ncmpi_$1_var$2_$3$4')')dnl
dnl
dnl GETPUT_API(get/put, kind, itype, coll/indep)
dnl
define(`GETPUT_API',dnl
`dnl
/*----< APINAME($1,$2,$3,$4)() >---------------------------------------------*/
int
APINAME($1,$2,$3,$4)(int ncid,
                     int varid,
                     ArgKind($2)
                     BufArgs($1,$3))
{
    int err;
    PNC *pncp;

    /* use NC_NAT to represent this is a flexible API */
ifelse(`$3',`',`    nc_type itype=NC_NAT;',
`$3',`long',`#if SIZEOF_LONG == SIZEOF_INT
    nc_type itype=NC_INT;
#elif SIZEOF_LONG == SIZEOF_LONG_LONG
    nc_type itype=NC_INT64;
#endif',`    nc_type itype=NC_TYPE($3);')

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements APINAME($1,$2,$3,$4)() */
    err = pncp->dispatch->`$1'_var(pncp->ncp, varid, ArgStartCountStrideMap($2),
                                   buf, ifelse(`$3', `', `bufcount, buftype',
                                                         `0, ITYPE2MPI($3)'),
                                   API_KIND($2), itype, CollIndep($4));

    if (err != NC_NOERR) return err;

    return NC_NOERR;
}
')dnl
dnl
/*---- PnetCDF flexible APIs ------------------------------------------------*/
foreach(`kind', (, 1, a, s, m),
        `foreach(`putget', (put, get),
                 `foreach(`collindep', (, _all),
                          `GETPUT_API(putget,kind,,collindep)'
)')')

/*---- PnetCDF high-level APIs ----------------------------------------------*/
foreach(`kind', (, 1, a, s, m),
        `foreach(`putget', (put, get),
                 `foreach(`collindep', (, _all),
                          `foreach(`iType', (ITYPE_LIST),
                                   `GETPUT_API(putget,kind,iType,collindep)'
)')')')

/* ncmpi_get/put_varn_<type>_<mode> API:
 *    type:   data type of I/O buffer, buf
 *    mode:   independent (<nond>) or collective (_all)
 *
 * arguments:
 *    num:    number of start and count pairs
 *    starts: an 2D array of size [num][ndims]. Each starts[i][*] indicates
 *            the starting array indices for a subarray request. ndims is
 *            the number of dimensions of the defined netCDF variable.
 *    counts: an 2D array of size [num][ndims]. Each counts[i][*] indicates
 *            the number of array elements to be accessed. This argument
 *            can be NULL, equivalent to counts with all 1s.
 *    bufcount and buftype: these 2 arguments are only available for flexible
 *            APIs, indicating the I/O buffer memory layout. When buftype is
 *            MPI_DATATYPE_NULL, bufcount is ignored and the data type of buf
 *            is considered matched the variable data type defined in the file.
 */
dnl
define(`NAPINAME',`ifelse(`$3',`',`ncmpi_$1_varn$2',`ncmpi_$1_varn_$3$2')')dnl
dnl
dnl VARN(putget,collindep,iType)
dnl
define(`VARN',dnl
`dnl
/*----< NAPINAME($1,$2,$3)() >-----------------------------------------------*/
int
NAPINAME($1,$2,$3)(int                ncid,
                   int                varid,
                   int                num,
                   MPI_Offset* const *starts,
                   MPI_Offset* const *counts,
                   BufArgs($1,$3))
{
    int err;
    PNC *pncp;

    /* use NC_NAT to represent this is a flexible API */
ifelse(`$3',`',`    nc_type itype=NC_NAT;',
`$3',`long',`#if SIZEOF_LONG == SIZEOF_INT
    nc_type itype=NC_INT;
#elif SIZEOF_LONG == SIZEOF_LONG_LONG
    nc_type itype=NC_INT64;
#endif',`    nc_type itype=NC_TYPE($3);')

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements NAPINAME($1,$2,$3)() */
    err = pncp->dispatch->`$1'_varn(pncp->ncp, varid, num, starts, counts,
                                    buf, ifelse(`$3', `', `bufcount, buftype',
                                                          `0, ITYPE2MPI($3)'),
                                    itype, CollIndep($2));

    if (err != NC_NOERR) return err;

    return NC_NOERR;
}
')dnl
dnl
/*---- PnetCDF flexible APIs ------------------------------------------------*/
foreach(`putget', (put, get),
        `foreach(`collindep', (, _all),
                 `VARN(putget,collindep)'
)')

/*---- PnetCDF high-level APIs ----------------------------------------------*/
foreach(`putget', (put, get),
        `foreach(`collindep', (, _all),
                 `foreach(`iType', (ITYPE_LIST),
                          `VARN(putget,collindep,iType)'
)')')

dnl
define(`IAPINAME',`ifelse(`$3',`',`ncmpi_$1_var$2',`ncmpi_$1_var$2_$3')')dnl
dnl
dnl IGETPUT_API(iget/iput/bput, kind, itype)
dnl
define(`IGETPUT_API',dnl
`dnl
/*----< IAPINAME($1,$2,$3)() >-----------------------------------------------*/
int
IAPINAME($1,$2,$3)(int ncid,
                   int varid,
                   ArgKind($2)
                   BufArgs(substr($1,1),$3),
                   int *reqid)
{   
    int err;
    PNC *pncp;

    /* use NC_NAT to represent this is a flexible API */
ifelse(`$3',`',`    nc_type itype=NC_NAT;',
`$3',`long',`#if SIZEOF_LONG == SIZEOF_INT
    nc_type itype=NC_INT;
#elif SIZEOF_LONG == SIZEOF_LONG_LONG
    nc_type itype=NC_INT64;
#endif',`    nc_type itype=NC_TYPE($3);')

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements IAPINAME($1,$2,$3)() */
    err = pncp->dispatch->`$1'_var(pncp->ncp, varid, ArgStartCountStrideMap($2),
                                   buf, ifelse(`$3', `', `bufcount, buftype',
                                                         `0, ITYPE2MPI($3)'),
                                   reqid, API_KIND($2), itype);

    if (err != NC_NOERR) return err;

    return NC_NOERR;
}
')dnl
dnl
/*---- PnetCDF flexible APIs ------------------------------------------------*/
foreach(`kind', (, 1, a, s, m),
        `foreach(`putget', (iput, iget, bput),
                 `IGETPUT_API(putget,kind,)'
)')

/*---- PnetCDF high-level APIs ----------------------------------------------*/
foreach(`kind', (, 1, a, s, m),
        `foreach(`putget', (iput, iget, bput),
                 `foreach(`iType', (ITYPE_LIST),
                          `IGETPUT_API(putget,kind,iType)'
)')')


/* ncmpi_iget/iput_varn_<type>_<mode> API:
 *    type:   data type of I/O buffer, buf
 *    mode:   indpendent (<nond>) or collective (_all)
 *
 * arguments:
 *    num:    number of start and count pairs
 *    starts: an 2D array of size [num][ndims]. Each starts[i][*] indicates
 *            the starting array indices for a subarray request. ndims is
 *            the number of dimensions of the defined netCDF variable.
 *    counts: an 2D array of size [num][ndims]. Each counts[i][*] indicates
 *            the number of array elements to be accessed. This argument
 *            can be NULL, equivalent to counts with all 1s.
 *    bufcount and buftype: these 2 arguments are only available for flexible
 *            APIs, indicating the I/O buffer memory layout. When buftype is
 *            MPI_DATATYPE_NULL, bufcount is ignored and the data type of buf
 *            is considered matched the variable data type defined in the file.
 *    reqid:  request ID returned to user
 */
dnl
define(`INAPINAME',`ifelse(`$2',`',`ncmpi_$1_varn',`ncmpi_$1_varn_$2')')dnl
dnl
dnl IVARN(iget/iput/bput, iType)
dnl
define(`IVARN',dnl
`dnl
/*----< ncmpi_$1_var$2() >---------------------------------------------------*/
int
INAPINAME($1,$2)(int                ncid,
                 int                varid,
                 int                num,
                 MPI_Offset* const *starts,
                 MPI_Offset* const *counts,
                 BufArgs(substr($1,1),$2),
                 int               *reqid)
{
    int err;
    PNC *pncp;

    /* use NC_NAT to represent this is a flexible API */
ifelse(`$2',`',`    nc_type itype=NC_NAT;',
`$2',`long',`#if SIZEOF_LONG == SIZEOF_INT
    nc_type itype=NC_INT;
#elif SIZEOF_LONG == SIZEOF_LONG_LONG
    nc_type itype=NC_INT64;
#endif',`    nc_type itype=NC_TYPE($2);')

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements INAPINAME($1,$2)() */
    err = pncp->dispatch->`$1'_varn(pncp->ncp, varid, num, starts, counts,
                                    buf, ifelse(`$2', `', `bufcount, buftype',
                                                          `-1, ITYPE2MPI($2)'),
                                    reqid, itype);

    if (err != NC_NOERR) return err;

    return NC_NOERR;
}
')dnl
dnl
/*---- PnetCDF flexible APIs ------------------------------------------------*/
foreach(`putget', (iget, iput, bput), `IVARN(putget)')

/*---- PnetCDF high-level APIs ----------------------------------------------*/
foreach(`putget', (iget, iput, bput),
        `foreach(`iType', (ITYPE_LIST),
                 `IVARN(putget,iType)'
)')

dnl
dnl VARD(get/put, collindep)
dnl
define(`VARD',dnl
`dnl
/*----< ncmpi_$1_vard$2() >--------------------------------------------------*/
int
ncmpi_$1_vard$2(int           ncid,
                int           varid,
                MPI_Datatype  filetype,  /* access layout to the variable in file
 */
                ifelse($1, `get', `void *buf', `const void *buf'),
                MPI_Offset    bufcount,
                MPI_Datatype  buftype)   /* data type of the buffer */
{
    int err;
    PNC *pncp;

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_$1_vard$2() */
    err = pncp->dispatch->$1_vard(pncp->ncp, varid, filetype, buf, bufcount,
                                  buftype, CollIndep($2));

    if (err != NC_NOERR) return err;

    return NC_NOERR;
}
')
dnl
foreach(`putget', (put, get),
        `foreach(`collindep', (, _all),
                 `VARD(putget,collindep)'
)')

dnl
dnl WAIT(collindep)
dnl
define(`WAIT',dnl
`dnl
/*----< ncmpi_wait$1() >-----------------------------------------------------*/
int
ncmpi_wait$1(int  ncid,
             int  num_reqs, /* number of requests */
             int *req_ids,  /* [num_reqs]: IN/OUT */
             int *statuses) /* [num_reqs], can be NULL */
{
    int err;
    PNC *pncp;

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_wait$1() */
    err = pncp->dispatch->wait(pncp->ncp, num_reqs, req_ids, statuses,
                               CollIndep($1));

    if (err != NC_NOERR) return err;

    return NC_NOERR;
}
')
WAIT()
WAIT(_all)

/*----< ncmpi_cancel() >-----------------------------------------------------*/
int
ncmpi_cancel(int  ncid,
             int  num_reqs, /* number of requests */
             int *req_ids,  /* [num_reqs]: IN/OUT */
             int *statuses) /* [num_reqs], can be NULL */
{
    int err;
    PNC *pncp;

    /* check if ncid is valid.
     * For invalid ncid, we must return error now, as there is no way to
     * continue with invalid ncp. However, collective APIs might hang if this
     * error occurs only on a subset of processes
     */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_cancel() */
    err = pncp->dispatch->cancel(pncp->ncp, num_reqs, req_ids, statuses);

    if (err != NC_NOERR) return err;

    return NC_NOERR;
}
