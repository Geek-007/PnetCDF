dnl Process this m4 file to produce 'C' language file.
dnl
dnl If you see this line, you can ignore the next one.
/* Do not edit this file. It is produced from the corresponding .m4 source */
dnl
/*
 *  Copyright (C) 2017, Northwestern University and Argonne National Laboratory
 *  See COPYRIGHT notice in top-level directory.
 */
/* $Id$ */

#if HAVE_CONFIG_H
# include <ncconfig.h>
#endif

#include <stdlib.h>

#include <dispatch.h>
#include <pnetcdf.h>
#include <nctypes.h>

/*----< ncmpi_inq_att() >----------------------------------------------------*/
int
ncmpi_inq_att(int         ncid,
              int         varid,
              const char *name, /* input, attribute name */
              nc_type    *xtypep,
              MPI_Offset *lenp)
{
    int err;
    PNC *pncp;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_inq_att() */
    err = pncp->dispatch->inq_att(pncp->ncp, varid, name, xtypep, lenp);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_inq_atttype() >------------------------------------------------*/
int
ncmpi_inq_atttype(int         ncid,
                  int         varid,
                  const char *name, /* input, attribute name */
                  nc_type    *xtypep)
{
    return ncmpi_inq_att(ncid, varid, name, xtypep, NULL);
}

/*----< ncmpi_inq_attlen() >-------------------------------------------------*/
int
ncmpi_inq_attlen(int         ncid,
                 int         varid,
                 const char *name, /* input, attribute name */
                 MPI_Offset *lenp)
{
    return ncmpi_inq_att(ncid, varid, name, NULL, lenp);
}

/*----< ncmpi_inq_attid() >--------------------------------------------------*/
int
ncmpi_inq_attid(int         ncid,
                int         varid,
                const char *name,
                int        *attnump)
{
    int err;
    PNC *pncp;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_inq_attid() */
    err = pncp->dispatch->inq_attid(pncp->ncp, varid, name, attnump);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_inq_attname() >----------------------------------------------*/
int
ncmpi_inq_attname(int   ncid,
                  int   varid,
                  int   attnum,
                  char *name) /* output, attribute name */
{
    int err;
    PNC *pncp;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_inq_attname() */
    err = pncp->dispatch->inq_attname(pncp->ncp, varid, attnum, name);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_copy_att() >---------------------------------------------------*/
int
ncmpi_copy_att(int         ncid_in,
               int         varid_in,
               const char *name,
               int         ncid_out,
               int         varid_out)
{
    int err;
    PNC *pncp_in, *pncp_out;

    /* check if ncid_in is valid */
    err = PNC_check_id(ncid_in, &pncp_in);
    if (err != NC_NOERR) return err;

    /* check if ncid_out is valid */
    err = PNC_check_id(ncid_out, &pncp_out);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_copy_att() */
    err = pncp_in->dispatch->copy_att(pncp_in->ncp,  varid_in, name,
                                      pncp_out->ncp, varid_out);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_rename_att() >-------------------------------------------------*/
int
ncmpi_rename_att(int         ncid,
                 int         varid,
                 const char *name,
                 const char *newname)
{
    int err;
    PNC *pncp;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_rename_att() */
    err = pncp->dispatch->rename_att(pncp->ncp, varid, name, newname);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

/*----< ncmpi_del_att() >----------------------------------------------------*/
int
ncmpi_del_att(int         ncid,
              int         varid,
              const char *name)
{
    int err;
    PNC *pncp;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_del_att() */
    err = pncp->dispatch->del_att(pncp->ncp, varid, name);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

include(`foreach.m4')dnl
include(`utils.m4')dnl

dnl
dnl GET_ATT(fntype)
dnl
define(`GET_ATT',dnl
`dnl
/*----< ncmpi_get_att_$1() >-------------------------------------------------*/
/* This is an independent subroutine.
ifelse(`$1',`text',` * This API never returns NC_ERANGE error, as text is not convertible to numerical types')
 */
int
ncmpi_get_att_$1(int             ncid,
                 int             varid,
                 const char     *name,
                 FUNC2ITYPE($1) *buf)
{
    int err;
    PNC *pncp;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_get_att_$1() */
    err = pncp->dispatch->get_att(pncp->ncp, varid, name, buf, NC_TYPE($1));
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}
')dnl

foreach(`iType', (text,schar,uchar,short,ushort,int,uint,long,float,double,longlong,ulonglong),
        `GET_ATT(iType)
')

/*----< ncmpi_get_att() >----------------------------------------------------*/
/* This is an independent subroutine */
/* user buffer data type matches the external type defined in file */
int
ncmpi_get_att(int         ncid,
              int         varid,
              const char *name,
              void       *buf)
{
    int err;
    PNC *pncp;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_get_att() */
    err = pncp->dispatch->get_att(pncp->ncp, varid, name, buf, NC_NAT);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

dnl
dnl PUT_ATT(fntype)
dnl
define(`PUT_ATT',dnl
`dnl
/*----< ncmpi_put_att_$1() >-------------------------------------------------*/
/* This is a collective subroutine, all arguments should be consistent among
 * all processes.
 *
 * Note from netCDF user guide:
 * Attributes are always single values or one-dimensional arrays. This works
 * out well for a string, which is a one-dimensional array of ASCII characters
 *
 * Note ncmpii_put_att_text will never return NC_ERANGE error, as text is not
 * convertible to numerical types.
 */
int
ncmpi_put_att_$1(int         ncid,
                 int         varid,
                 const char *name,     /* attribute name */
                 ifelse(`$1',`text',,`nc_type xtype,')
                 MPI_Offset  nelems,   /* number of elements in buf */
                 const FUNC2ITYPE($1) *buf) /* user write buffer */
{
    int err;
    PNC *pncp;
    nc_type itype=NC_TYPE($1);

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_put_att_$1() */
    err = pncp->dispatch->put_att(pncp->ncp, varid, name,
                                  ifelse(`$1',`text',`NC_CHAR,',`xtype,')
                                  nelems, buf, itype);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}
')dnl

foreach(`iType', (text,schar,uchar,short,ushort,int,uint,long,float,double,longlong,ulonglong),
        `PUT_ATT(iType)
')

/*----< ncmpi_put_att() >----------------------------------------------------*/
/* This is a collective subroutine, all arguments should be consistent among
 * all processes. This API is for when the user buffer data type matches the
 * external type defined in file.
 */
int
ncmpi_put_att(int         ncid,
              int         varid,
              const char *name,
              nc_type     xtype,
              MPI_Offset  nelems,
              const void *buf)
{
    int err;
    PNC *pncp;

    /* check if ncid is valid */
    err = PNC_check_id(ncid, &pncp);
    if (err != NC_NOERR) return err;

    /* calling the subroutine that implements ncmpi_put_att() */
    err = pncp->dispatch->put_att(pncp->ncp, varid, name, xtype, nelems, buf, xtype);
    if (err != NC_NOERR) return err;

    return NC_NOERR;
}

